# 高级班 01

## 技巧 —— 舍弃不可能

题目：给定一个数组，求如果排序之后，相邻两数的最大差值。要求时间复杂度 O(N)，且要求不能用非基于比较的排序。

流程：
<!-- TODO: 完善流程 -->
1. 数组中有 n 个数，准备 n+1 个容器
2. 先遍历一遍数组找出最小值和最大值，如果两个值相同，直接返回 0
3. 将最小值和最大值的区间等分成 n+1 份，然后再次遍历数组
4. ...

```py
from random import randint
from typing import List

def maxGap(arr):
    if not arr or len(arr) < 2:
        return 0
    def bucket(num, length, min_val, max_val):

        return (num - min_val) * length // (max_val - min_val)

    L = len(arr)
    min_val = float('inf')
    max_val = float('-inf')
    for a in arr:
        min_val = min(min_val, a)
        max_val = max(max_val, a)
    if min == max:
        return 0

    hasNum = [False] * (L + 1)
    maxs = [None] * (L + 1)
    mins = [None] * (L + 1)
    bucket_idx = 0
    for num in arr:
        bucket_idx = bucket(num, L, min_val, max_val)
        mins[bucket_idx] = num if not hasNum[bucket_idx] else min(num, mins[bucket_idx])
        maxs[bucket_idx] = num if not hasNum[bucket_idx] else max(num, maxs[bucket_idx])
        hasNum[bucket_idx] = True

    gap = 0
    last_max = maxs[0]
    for i in range(L+1):
        if hasNum[i]:
            gap = max(gap, mins[i] - last_max)
            last_max = maxs[i]
    return gap


def comparator(arr: List[int]):
    if not arr or len(arr) < 2:
        return 0
    arr.sort()
    gap = float('-inf')
    for i in range(1, len(arr)):
        gap = max(gap, arr[i] - arr[i-1])
    return gap



def main():
    testTime = 500000
    maxSize = 100
    maxValue = 100
    succeed = True

    def generateRandomArray(maxSize, maxValue):
        return [randint(-maxValue, maxValue) for _ in range(maxSize)]
    def copyArray(arr):
        return [*arr]

    for _ in range(testTime):
        arr1 = generateRandomArray(maxSize, maxValue)
        arr2 = copyArray(arr1)
        if maxGap(arr1) != comparator(arr2):
            succeed = False
            break
    print('✔️' if succeed else '❌')

main()
```

