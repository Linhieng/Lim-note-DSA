## 🍕 并查集

### 岛问题

一个矩阵中只有 0 和 1 两种值, 每个位置都可以和自己的上、下、左、右 四个位置相连, 如果有一片1连在一起, 这个部分叫做一个岛, 求一个矩阵中有多少个岛?

方法很简单:
- 遍历每个元素, 识别到 1 时, 代表碰到一个岛
- 此时对这个岛进行感染, 将该岛的所有元素设置为 0
- 感染完成后继续遍历过程, 如果又遇到一个 1, 说明这个岛肯定是新岛, 再次感染
- 如此反复, 最终就可以求出岛的数量

时间复杂度 O(M*N)
- 遍历时, 每个元素都会访问一次
- 感染过程时, 一个元素最多被访问四次(从上下左右四个方向访问进来)

```java
int countIslands(int[][] m) {
    if (m == null || m[0] == null) {
        return 0;
    }
    int N = m.length;
    int M = m[0].length;
    int res = 0;

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (m[i][j] == 1) {
                // 每找到一个岛, 加1
                res++;
                // 同时感染这个岛, 即属于这个岛的元素, 值将不会是 1
                infect(m, i, j, N, M);
            }
        }
    }
    return res;
}

void infect(int[][] m, int i, int j, int N, int M) {
    // 感染过程也很简单, 利用递归, 因为只有四周相连, 所以不断像四个方向感染
    if (i < 0 || i >= N || j < 0 || j >= M // 防止出界
    || m[i][j] != 1) { // 不是 1, 说明是 "海"
        return;
    }
    m[i][j] = 2; // 感染
    // 继续感染四个方向
    infect(m, i+1, j, N, M);
    infect(m, i-1, j, N, M);
    infect(m, i, j+1, N, M);
    infect(m, i, j-1, N, M);
}
```

### 并查集

并查集提供的接口:
- 初始化, 接收一个元素列表, 每个元素初始为单独一个集合
- union, 合并集合。
- is_same_set, 查询是否同一集合。

经典结构实现时难以两全其美:
- 链表结构实现时
    - 合并集合时很简单, 只需要将两条链表合并在一起, 时间复杂度是 O(1)
    - 但查询是否属于同一集合时, 需要遍历这条链表, 时间复杂度是 O(N)
- 哈希表结构实现时
    - 查询是否在同一集合时很快, 时间复杂度是 O(1)
    - 合并集合时慢, 因为需要将一个集合的所有元素导入到另一个集合中, 时间复杂度是 O(N)

并查集结构, 可视化出来后就是一个向上指的图。 即每一个元素都指向自己的父元素, 同一个集合中的元素会有一个代表元素。
- 当合并两个集合时, 只需要将一个集合的代表元素指向另一个集合的代表元素就可以了, 时间复杂度 O(1)
- 当查询是否在一个集合, 只需要查询代表元素是否是一个, 就可以了。 时间复杂度是 O(1) 。(数学家都花了好多年证明的)
    - 查询过程中有一个优化, 因为合并是将代表元素指向代表元素。 所以查询时需要不断的往上找才能找到代表元素
    - 优化: 在往上找的过程中, 保存遍历过的父元素, 找到代表元素后, 重新遍历这些父节点, 将他们都指向代表元素。 这样下次查询时就是 O(1) 级别的。

```java
// 一个样本包成一个元素
class Element<V> {
    V value;
}
class UnionFindSet<V> {
    HashMap<V, Element<V>> elementMap;
    // key 是某个元素, value 是该元素的父元素。 父元素一直往上将会到达该集合的代表元素
    HashMap<Element<V>, Element<V>> fatherMap;
    // key 是某个集合的代表元素, value 是该集合的大小
    HashMap<Element<V>, Integer> sizeMap;

    // 初始化
    UnionFindSet(List<V> list) {
        elementMap = new HashMap<>();
        fatherMap = new HashMap<>();
        sizeMap = new HashMap<>();
        for (V value : list) {
            Element<V> element = new ELement<V>(value);
            elementMap.put(value, element);
            fatherMap.put(element, element);
            sizeMap.put(element, 1);
        }
    }

    // 找到该集合所在的代表元素, 同时扁平化(查找过程中的节点全部直接指向代表元素)
    ELement<V> findHead(Element<V> element) {
        Stack<Element<V>> path = new Stack<>();
        while (element != fatherMap.get(element)) {
            path.push(element);
            element = fatherMap.get(element);
        }
        while (!path.isEmpty()) { // 扁平化
            fatherMap.put(path.pop(), element);
        }
        return element;
    }

    boolean isSameSet(V a, V b) {
        // 首先要确保这两个元素是并查集中的元素
        if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
            // 然后再查看是不是同一个集合里的
            return findHead(elementMap.get(a) == findHead(elementMap.get(b)))
        }
        return false;
    }

    void union(V a, V b) {
        if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
            Element<V> aF = findHead();
            Element<V> bF = findHead();
            if (aF != bF) {
                // 不在一个集合, 则将小集合合并到大集合中
                Element<V> big = sizeMap.get(aF) >= sizeMap.get(bF) ? aF : bF;
                Element<V> small = big == aF ? bF : aF;
                fatherMap.put(small, big);
                sizeMap.put(big, sizeMap.get(aF) + sizeMap.get(bF));
                sizeMap.remove(small);
            }
        }
    }

}
```

### 并行解决岛问题

先讨论两个 CPU 的情况, 两个 CPU, 一个负责一块区域, 查询到的岛数量肯定是大于等于实际岛数量的。
多出来的岛, 是因为边界被切掉了, 所以我们的重点在于, 合并区域时, 如何处理边界上的点的信息, 以下图为例:

原始地图如下, 很明显只有一个岛
```
111111111111111111111111
000000000000000000111111
111111111111111111111111
111111000000000000000000
111111111111111111111111
000000000000000000111111
111111111111111111111111
```
切割两边后变成下面这样:
```
111111111111    111111111111
000000000000    000000111111
111111111111    111111111111
111111000000    000000000000
111111111111    111111111111
000000000000    000000111111
111111111111    111111111111
```
两个 CPU 各自处理一块, 然后会发现, 左边计算出 3 个岛, 右边计算出 2 个岛。
让他们的计算的时候, 为每一个接触岛边界的点标记所在的岛, 比如用 ABCDE 表示
```
11111111111A    D11111111111
000000000000    000000111111
11111111111B    D11111111111
111111000000    000000000000
11111111111B    E11111111111
000000000000    000000111111
11111111111C    E11111111111
```
在合并的过程中, 为 ABCDE 初始化成并查集, 然后利用边界信息依次合并几个集合:
- 检查 A D 是否一个集合, 不在一个集合, 故合并, 此时岛的数量5-1=4
- 检查 B D 是否是一个集合, 不在一个集合, 故合并, 岛的数量 4-1=3
- 检查 B E 是否在一个集合, 不在一个集合, 故合并, 岛的数量 3-1=2
- 检查 C E 是否在一个集合, 不在一个集合, 故合并, 岛的数量 2-1=1
- 只在合并的时候岛的数量减一, 如果两个点在一个集合, 则不合并, 此时岛的数量也不会减1

这是两个 CPU 的情况, 当多个 CPU 时, 会被划分为更多的区域, 此时就会出现 4 个边界的情况, 处理方式是一样的, 只不过编程起来麻烦点。
但方法要懂。

这其实一个一个 map reduce 过程, 即拆分, 然后合并。

## 🍕 KMP 算法

如何判断一个字符串 str_d 是否是另外一个字符串 str 的子串? 要求时间复杂度是 O(N)

首先, 肯定先判断 str_d 长度小于 str 长度。

暴力破解: 遍历 str, 对每一个字符, 都判断, 以这个字符串开头, 能否匹配出 a。 这种时间复杂度是 O(N*M), N 是 str 长度, M 是 a 长度。

先了解一个信息: 最大相同前后缀长度, 即一个字符串的前缀和后缀相同时的最大长度。 这里要求最大长度不能等于字符串长度。
- 字符串 aaaaa 的最大相等前后缀长度
    - 长度4时, 前缀 aaaa, 后缀 aaaa, 故最长前后缀长度是 4, 不能是 5
- 比如 aabaab 的最大相等前后缀长度
    - 长度 1 时, 前缀 a, 后缀 b, 不相同
    - 长度 2 时, 前缀 aa, 后缀 ab, 不相同
    - 长度 3 时, 前缀 aab, 后缀 aab, 相同
    - 长度 4 时, 前缀 aaba, 后缀 baab, 不相同
    - 前缀 5 时, 前缀 aabaa, 后缀 abaab, 不相同
    - 故最大相等前后缀长度为 3

- 然后, 对 str_d 求取一个信息: 对每个位置上的字符, 都求取前面字符串的最大相同前后缀长度。
- 首先, 第一个位置, 它前面的字符串为空, 所以人为规定长度是 -1
- 第二个位置, 前面的字符串长度是 1, 因为最大相同前后缀长度不能等于字符串长度, 所以长度是 0
- 第二个位置, 前面字符串长度是 2, 求取该字符串的最大相同前后缀长度
- ... 不断执行, 直到每一位都拥有这些信息, 将这些信息放在 `next` 数组中。 数组头两个元素大小可以直接锁定 -1 和 0


### KMP

暴力破解的比对过程是: 当前发现 str 的 i 位置无法匹配到 a 时, 下一个位置是 i+1, 也就是 i 只会加1, 之前在 i 位置上进行匹配时获取的信息全部扔掉了。

KMP 算法就是利用 `next` 数组对这个比较过程进行加速, 即利用好已经比较过的信息。

比如 str_b 是 "", 先计算出这个字符串的 `next` 数组

```
假设现在已经是在比较查看 str 以 c 开头, 是否能够匹配出的位置上,
str:    .....c e o e S F c e o e S ..........
             ↑
str_d:       c e o e S F c e o e F ......
             ↑

匹配到 S 时, 会发现不匹配
        .....c e o e S F c e o e S ..........
                                 ↑
             c e o e S F c e o e F ......
                                 ↑

按照暴力的方法, 下一次, 它的 str 指针只会走一步, 即判断以 e 开头是否能够匹配 str_d

但是我们可以很明显的发现, 完全可以跳过 str 的 c e o e S F c e o e S 这段, 因为它肯定不可能匹配成功
即 str 的指针可以继续停留在 S 位置上, 不用回退。
同时 str_d 的指针, 也不需要完全回退到 开头, 而是可以直接从 S 开始继续比较。
            .....c e o e S F c e o e S ..........
                                     ↑
                             c e o e S F c e o e F ......
                                     ↑
问题在于为什么可以这样? 为什么可以让 str 指针不回退, 并且 str_d 的指针只回退一半?
原因就在于 next 数组。
前面我们是比较到 str_d 的 F 时, 发现匹配不成功的
        c e o e S F c e o e F ......
                            ↑
这个时候, 查看该 F 前面的字符串的最大相同前后缀长度是 4, 即 直接从 next 数组中可以得出 next[F] = 4
这说明什么? 这说明此时的 str 前面 4 个字符, 和 str_d 的开头四个字符是完全一样的:
                    .....c e o e S F c e o e S ..........
                                     | | | | ↑
                         c e o e S F c e o e F ......
                         | | | |     | | | | ↑
这个信息是这一次匹配失败时获得的信息, 我们通过 next 数组成功保存了这部分信息, 所以 str 指针不动, 而 str_d 的直接直接指向下标为 4 的位置:
                    .....c e o e S F c e o e S ..........
                                             ↑
                         c e o e S F c e o e F ......
                                 ↑
也就是说, 此时我们其实相当于暴力破解从 c 位置开始比较, 并且比较到了 S 位置
                    .....c e o e S F c e o e S ..........
                                     ↑ --->  ↑
                         c e o e S F c e o e F ......
                         ↑ --->  ↑
这个很好理解, 但我们还需要证明, 我们直接跳过的 str 的 e-F 部分, 一定无法匹配成功
                    .....c e o e S F c e o e S ..........
                           ↑-------↑ 一定无法匹配成功
                         c e o e S F c e o e F ......
这个也很好证明, 原因还是在 next 数组中, next 数组中某个元素的值的含义是:   当前元素前的字符串的最大相同前缀后缀长度
首先, 我们要明确, 当前条件下一定成立的是什么? 一定成立的是 str 的后半段和 str_d 的 F 前面的字符串的前缀后缀相同
这个是一定成立的, 在这个条件下, 我们来假设 str 的 e-F 部分, 存在一个字符, 能够作为匹配成功的 "头", 看看有没有机会成立:
                        .....c e o e S F c e o e S ..........
                                         ↑ ↑ ↑ ↑
                             c e o e S F c e o e F ......
                                         ↑ ↑ ↑ ↑
 因为我们假设了 e-F 是有机会匹配 str_d 的, 而 e-F 后面部分又一定与 str_d 的其中一段相等,
 即 e-F 其中某个字符作为头, 它能够匹配 str_d 的头, e-F 后面的四个字符长度也一定是匹配成功的,
 也就是说 , e-F 加上后面四个字符, 是能够作为 str_d 的前缀的, 而又因为 e-F 后面的四个字符, 和 str_d 的 F 前的字符串的后缀相同,
 所以该假设的情况, 将导致找出了更长的相同前缀后缀的长度。 所以这个假设是不成立的。 因为 next 数组是一定的, 不会错的。
```

```
  设这个位置叫 1
             ↓
str:    .....b......k......b............2 x..........
                             ||||||||||||
str_d:       b.........2...b............2 y
             ↑
  设这个位置叫 1

```
1. 首先, 一定成立的是: `str` 的 1-2 等于 `str_d` 中的 1-2, 他们是到达 x 和 y 时才发现不一样的。
2. 假设 str 的 1-b 之间存在一个 k 开头的子串能够匹配 str_d
3. 则这个 k 开头的子串至少要满足一个条件: k-2 是 str_d 的前缀,
4. 而又因为 k-2 等于 str_d 中 y 前面字符串的后缀, 这将导致 y 前面字符串出现更长的相同前缀后缀长度
5. 所以这个假设不成立


【总结】:
- 计算 str_d 的 next 数组, 数组的元素值表示, 当前字符的前面字符串的最长相同前后缀长度。
- KMP 中 str 的指针不会回退, 即: 已经比较过的信息会一直保留
- str_d 的也不是每次都会从第一个字符串开始比较, 而是利用 next 数组的信息, 回退到前缀的下一个位置。 没有前缀时才会从第一个字符开始比较。

```java
int GetIndexOf(String s, String m) {
    if (s == null || m == null || m.length() < 1 || s.length() < m.length()) {
        return -1;
    }
    char[] str = s.toCharArray();
    char[] str_d = m.toCharArray();
    int str_i = 0;
    int str_d_i = 0;
    int[] next = getNextArray(str_d); // O(M)
    // KMP
    while (str_i < str.length && str_d_i < str_d.length) { // O(N)
        if (str[str_i] == str_d[str_d_i]) {
            str_i++;
            str_d_i++;
        } else if (str_d_i == 0) { // 等效于 next[str_d_i] == -1
            str_i++;
        } else {
            str_d_i = next[str_d_i]; // str_d_i 回退
        }
    }
    return str_d_i == str_d.length ? str_d - str_d_i : -1;
}
```

证明 KMP 代码中的 while 循环是 O(N) 级别的: 设 "i1" 是 str_i, i2 是 str_d_i:
- 整个 while 循环证明复杂度的难点在于, "i1" 会增加, i2 又会减少, 所以一时难以知道循环会跑多久
- 创建出两个变量 "i1" 和 "i1-i2",
    - "i1" 的最大值是 N, N 表示 str 的长度
    - "i1" - i2 的最大值也是 N, 因为 i2 最小值是 0
- 现在分析循环中的三个分支
    - 分支一, "i1" 和 i2 都增加, 故 "i1" 增加, "i1-i2" 不变
    - 分支二, "i1" 增加, i2不变, 故 "i1" 增加, "i1-i2" 增加
    - 分支三, i2 减小, "i1" 不变, 故 "i1" 不变, "i1-i2" 增加
- 每次循环都会执行其中一个分支, 而不管是哪个分支, "i1" 和 "i1-i2" 肯定有一个值在变大, 所以 "i1" 和 "i1-i2" 的变化幅度最大就是 2N, 故时间复杂度是 O(N)。
- 不清楚? 那就再详细说明一下:
- 循环的结束条件是 "i1" 超出 N 或者 i2 超出 N
    - 由于每次循环, "i1" 和 "i1-i2" 一定有一个值在增加, 并且两个值都不会变小,
    - i1最多增加到 N, "i1-i2" 也最多增加到 N, 考虑普通情况
    - "i1" 直接增加到 N 了, 循环结束, 时间复杂度 O(N)
    - i2 直接增加到 N 了, 循环结束, 时间复杂度 O(N)
    - i2 减小了, 即 "i1-i2" 增加, 但因为 "i1-i2" 最大是 N, 所以 i2 最多循环 N 次后, 就不可能再减小了
        - 而 i2 不能减小, "i1-i2" 也不能再增加了, 前面又证明了每次循环一定会有一个值在变大
        - 所以当 i2 循环减小 N 次后, 只可能是 "i1" 增加 N 次,
        - 然后循环结束, 此时最大的变化幅度是 2N, 时间复杂还是 O(N)
- 所以, 得证时间复杂度 O(N)

### KMP 的 next 数组


`next` 数组的求解: 最长相同前后缀长度
- 第一个元素和第二个元素的 最长相同前后缀长度 可以直接手动赋值。
- 后面元素, 也可以借助前面已经求出来的 最长相同前后缀长度 来求取属于自己的 最长相同前后缀长度。

```
假设当前求第 i 个位置的 最长相同前后缀长度,
..........    ..........  i-1  i
                           7
i-1 位置求出来的 最长相同前后缀长度 是 7
--------- .... ---------  i-1  i
    7              7
如果 i-1 位置的前缀后一个元素, 等于 i-1 元素, 则说明 i 位置的 最长相同前后缀长度 长度为 8
--------- .... ---------  i-1  i
         a                 a
```

先证明一下为什么 i 位置的 最长相同前后缀长度 只能 +1。
使用反证法
```
假设 i 位置的 最长相同前后缀长度 是 10, i-1 位置的 最长相同前后缀长度 是 7
..........    ..........  i-1  i
                           7   10
则说明:
..........---i-1    ..........---i-1  i
0              9    j            k
如果 0-9 到 j-k 的元素是相同的,
那么 0-8 到 j-k-1 的元素也一定是相同的
这种情况下, i-1 位置上的 最长相同前后缀长度 应该是 9, 而不是 7
这与事实不符, 所以假设不成立, i 位置的 最长相同前后缀长度 减去 i-1 位置的值, 不可能大于 1
```

```
当 i-1 的值和 j 的值不相同时, 直接跳到 j 查看 j 的 最长相同前后缀长度。
.........j  .........i-1  i
```

```
然后以同样的方式, 比较 k 和 i-1 的值是否相同, 相同的话, 就在 j 的 最长相同前后缀长度 基础上 +1
....k ....j  ..............i-1  i
          3                 7
```
为什么直接跳到 k 而不看看 (k, j) 之间是否可能形成相同前后缀呢?
经过证明, 如果 (k,j) 之间能形成相同前后缀, 则 j 的 最长相同前后缀长度 的计算将会是错误的。
比如 j-1 位置可以形成相同前后缀, 并且 k 不等于 j-1, 则会发现 0-j-1 位置的数值将会都相同, 此时 k 的值应该等于 j-1

假设 next[i-1] = 7, 如果第 8 个数字不等于 i-1 时, 那么会直接跳到 next[7] 的位置上。
- 当 位置7 = i-1 时, next[7] 的值就会是 6
- 当 位置6 = i-1 时, next[7] 的值就会是 5
- 当 位置5 = i-1 时, next[7] 的值就会是 4
- 当 位置4 = i-1 时, next[7] 的值就会是 3
- 当 位置3 = i-1 时, next[7] 的值就会是 2
- 当 位置2 = i-1 时, next[7] 的值就会是 1
- 当 位置1 = i-1 时, next[7] 的值就会是 0
- 综上, 按照这种规律, 应该就能找到证明的思路, 所以直接跳到了 next[7] 的值上, 然后看他的下一位。
- 实际证明有时间再找找, 或者尝试自己写写。 反正就是,
- 根据前缀后缀相同, 还有假定的条件 位置k 的值等于 i-1, 会出现错位, 然后导致一个循环,
- 比如 错一位, 则是 aaaaaaa, 错两位, 则是 abababa, 错三位, 则是 abcabca, 同理...


```java
int[] getNextArray(char[] ms) {
    if (ms.length == 1) {
        return new int[] {-1};  // 首元素位置的值是什么其实无所谓
    }
    int[] next = new int[ms.length];
    next[0] = -1;
    next[1] = 0;
    int i = 2; // next 数组下标
    int cn = 0;
    while (i < next.length) {
        if (ms[i - 1] == ms[cn]) { // 如果前一个元素的最长前缀的下一个元素, 和前一个元素相同, 则说明当前位置的最长相同前后缀长度可以直接在前一个的基础上+1
            next[i++] = ++cn;
        } else if (cn > 0) {
            cn = next[cn]; // 如果无法在前一个元素的基础上 +1, 那就直接跳过一半, 继续判断。
        } else {
            next[i++] = 0; // 跳到 0 元素了, 找不到相同前后缀, 说明没有相同前后缀。
        }
    }
    return next;
}
```