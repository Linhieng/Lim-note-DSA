## 🍕 快排空间复杂度

首先, 快排在执行 partition 的过程中会申请空间, 即申请一块空间用来划分, 划分结束后可以确定一个(或一批)数的正确位置。

考虑最坏的情况, 每次划分后, 划分值所在的正确位置都是在最侧, 也就是每次递归申请的空间是 N, N-1, N-2, ... 故最差情况下空间复杂度是 `O(N^2)`。

考虑最好的情况, 每次划分后, 划分值所在的正确位置都在中间, 即每次递归申请的空间是是母问题的一半(左侧递归结束后空间会释放, 释放的空间可以供右侧递归使用), 故最好情况下空间复杂度是 `O(log(N))`。

和计算时间复杂度类似, 随机选取划分值时, 正确位置是等概率随机的, 然后求概率的累加, 最终能收敛到 `log(N)` 的水平。

## 🍕 完全二叉树

什么是完全二叉树? 看下面几个数的结构应该就明白了

```
            完全二叉树? ✔️                    ||             完全二叉树? ❌
      *            *             *           |      *            *             *
    /   \        /   \         /   \         |    /            /   \         /   \
   *     *      *     *       *     *        |   *            *     *       *     *
  /            / \   /       / \   / \       |  /              \   /       / \     \
 *            *   * *       *   * *   *      | *                * *       *   *     *
```

简单的说, 完全二叉树, 就是只允许最后一层出现右侧缺口, 否则不是完全二叉树。


在学习二叉树时, 我们常常画出数的结构图来学习, 比如下面是一个完全二叉树:

```
     1
   /   \
  2     3
 / \   /
4   5 6
```

但在计算机上, 二叉树的存储需要满足计算机的要求。 比如使用数组来存储二叉树。

举例, 一个数组为 [4,5,1,2,4,5], 它所对应的完全二叉树结构如下所示

```
     4
   /   \
  5     1
 / \   /
2   4 5
```

如果将这个树上显示的值换为数组的下标, 则如下所示:

```
     0
   /   \
  1     2
 / \   /
3   4 5
```

观察这些数组下标, 可以发现规律,
下标为 `i` 对应的节点：
- 它的左侧子节点下标为 `2*i+1`,
- 它的右侧子节点下标为 `2*i-1`,
- 它的父节点下标为 `(i-1)/2`


## 🍕! 堆

堆的结果是完全二叉树结构

大根堆, 每一颗子树, 它的最大值是头节点
小跟堆, 每一颗子树, 它的最小值是头节点

### 如何维持大根堆

...

操作1: 用户给我一个数字, 如何维持大根堆?
操作2: 用户让我删除最大值, 如何维持大根堆?
操作3: 用户修改指定位置的值, 如何维持大根堆?
节点数量为 N, 和树的高度是 logN 级别, 故
操作3, 维持代价是 logN
操作2, 维持代价是 logN

heapInsert, heapify

## 🍕! 堆排序

## 🍕! 堆排序扩展

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

## 🍕! 堆扩容代价

成倍扩容

## 🍕! 调用系统堆注意

有时候的需求, 需要自己手写堆, 才高效

## 🍕! 比较器

比较器, 就是定义比较的规则, 对于数字, 比较规则很容易, 但是对于某个对象, 比较的规则就需要手写了, 不然系统默认会是按地址大小比较。

比较器都有一个统一的潜台词:
- 返回负数的时候，第一个参数排在前面
- 返回正数的时候，第二个参数排在
- 前面返回 0 的时候，谁在前面无所谓

## 🍕 非比较排序算法

前面介绍的排序算法(冒泡, 插入, 选择, 归并, 快速, 堆), 都是基于比较的排序, 他们的时间复杂度通常是 `O(N^2)` 或 `O(N*log(N))`。

但实际使用中, 某些情景下可以有更加灵活的排序方法, 这种情况下可以造出时间复杂度为 `O(N)` 的排序算法。

### 计数排序

当待排序的数据中, 数据都是正整数, 并且最大值和最小值的差值不大时, 可以考虑采用计数排序。

假设情景: 要对公司员工的年龄进行排序, 因为人的年龄基本是在 (0, 200] 范围内的。

基本思路:
- 创建一个初值为 0, 大小为 200 的数组。
- 遍历员工年龄, 将他们的年龄作为下标, 每次将下标将对应的位置加一
- 最终这个数据就存储了排序后的信息。

故, 对于数据量大, 同时数据范围小的数据, 计数排序的优点非常明显 —— 占用空间少, 并且时间复杂度为 `O(N)`。
最经典的就是, 对公司近万人的年龄排序。

### 基数排序 1

假设情景: 数字都是正整数

基本思路:
- 定义 10 个桶, 编号依次是 0-9, 因为正整数每一位上的数字只可能是这 10 种结果之一
- 入桶: 初次遍历数组, 先根据当前数个位上的值, 决定将当前数放到哪个桶里面去
- 出桶: 然后将桶中的数字从左往右(从0到9)依次"倒出来", 桶内取出数据要求先进先出。 (即每个桶的结构要能够实现先进先出功能——队列)
- 入桶: 再次遍历数组, 此时根据当前数十位上的值, 决定将当前数放到哪个桶里面去
- 出桶: 继续从左往右, 将桶中的数字按先进先出的方式倒出来
- 不断重复上面过程, 直到根据最大数字的最高位也完成入桶出桶操作。

核心: 先根据个位数入桶出桶, 再根据十位数入桶出桶, ...

举个🌰:

```
假设有数组 arr
         ┌─────┬─────┬─────┬─────┬─────┐
    arr: │ 017 │ 013 │ 025 │ 100 │ 072 │
         └─────┴─────┴─────┴─────┴─────┘

定义 10 个桶如下:

┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃
┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛
   0         1         2         3         4         5         6         7         8         9

每次进出桶时, 根据某一位上的数, 决定将该数字放到哪个桶里面去。
处理位的顺序是: 先个位数, 然后十位数, 以此类推......
从左到右遍历数组 arr

1️⃣
先看个位上的数, 然后将他们依次放入桶中, 如下所示:
    ┌─────┬─────┬─────┬─────┬─────┐
    │ 017 │ 013 │ 025 │ 100 │ 072 │
    └   ↑ ┴   ↑ ┴   ↑ ┴   ↑ ┴   ↑ ┘
入桶
    ┃ 100 ┃   ┃ 013 ┃   ┃ 072 ┃   ┃     ┃   ┃     ┃   ┃ 025 ┃   ┃     ┃   ┃ 017 ┃   ┃     ┃   ┃     ┃
    ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛
        0         1         2         3         4         5         6         7         8         9
然后按照从左到右的顺序, 将桶中的数字依次取出。 取出桶里的数字时, 依据先进先出的方式取出。 最终数组 arr 更新为:
         ┌─ ─ ─┬─ ─ ─┬─ ─ ─┬─ ─ ─┬─ ─ ─┐
    arr: │ 100 │ 013 │ 072 │ 025 │ 017 │
         └─ ─ ─┴─ ─ ─┴─ ─ ─┴─ ─ ─┴─ ─ ─┘


2️⃣
按照同样的步骤, 这次是看十位上的数, 然后将他们依次入桶: 如下所示:
    ┌─────┬─────┬─────┬─────┬─────┐
    │ 100 │ 013 │ 072 │ 025 │ 017 │
    └  ↑  ┴  ↑  ┴  ↑  ┴  ↑  ┴  ↑  ┘
入桶:
    ┃     ┃   ┃ 017 ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃
    ┃ 100 ┃   ┃ 013 ┃   ┃ 025 ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃ 072 ┃   ┃     ┃   ┃     ┃
    ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛
       0         1         2         3         4         5         6         7         8         9
出桶:
         ┌─ ─ ─┬─ ─ ─┬─ ─ ─┬─ ─ ─┬─ ─ ─┐
    arr: │ 100 │ 013 │ 017 │ 025 │ 072 │
         └─ ─ ─┴─ ─ ─┴─ ─ ─┴─ ─ ─┴─ ─ ─┘


3️⃣
    ┌─────┬─────┬─────┬─────┬─────┐
    │ 100 │ 013 │ 017 │ 025 │ 072 │
    └  ↑  ┴  ↑  ┴  ↑  ┴  ↑  ┴  ↑  ┘
入桶:
    ┃ 072 ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃
    ┃ 025 ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃
    ┃ 017 ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃
    ┃ 013 ┃   ┃ 100 ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃   ┃     ┃
    ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛   ┗ ━↓━ ┛
      0         1         2         3         4         5         6         7         8         9
出桶:
         ┌─ ─ ─┬─ ─ ─┬─ ─ ─┬─ ─ ─┬─ ─ ─┐
    arr: │ 013 │ 017 │ 025 │ 072 │ 100 │
         └─ ─ ─┴─ ─ ─┴─ ─ ─┴─ ─ ─┴─ ─ ─┘

END
```

### 基数排序 2 - 代码优化

基数排序 1 中, 创建了 10 个桶, 每个桶都是一个特定的数据结构, 比如队列。
```
    ┃       ┃   ┃       ┃   ┃       ┃   ┃       ┃   ┃       ┃   ┃       ┃   ┃       ┃   ┃       ┃   ┃       ┃   ┃       ┃
    ┗ ━ 0 ━ ┛   ┗ ━ 1 ━ ┛   ┗ ━ 2 ━ ┛   ┗ ━ 3 ━ ┛   ┗ ━ 4 ━ ┛   ┗ ━ 5 ━ ┛   ┗ ━ 6 ━ ┛   ┗ ━ 7 ━ ┛   ┗ ━ 8 ━ ┛   ┗ ━ 9 ━ ┛
```

基数排序 2 中, 不需要创建 10 个桶, 只需要一个长度为 10 的数组 count, 用来统计"数频", 外加一个辅助数组 help, 用来存储每次"出桶"后的数组
```
           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
    count: │     │     │     │     │     │     │     │     │     │     │
           └  0  ┴  1  ┴  2  ┴  3  ┴  4  ┴  5  ┴  6  ┴  7  ┴  8  ┴  9  ┘

          ┌─────┬──......──┬─────┐
    help: │     │  ......  │     │  help 长度与待排序数组相同
          └──0──┴──......──┴──?──┘
```

基数排序 2 中的计算 count 数组的方式如下:

1. 先看指定位上的值, 然后统计他们的数频, 比如查看个位上的值:
```
以数组 arr 为例:
         ┌─────┬─────┬─────┬─────┬─────┬─────┐
    arr: │ 017 │ 013 │ 025 │ 101 │ 033 │ 072 │
         └   ↑ ┴   ↑ ┴   ↑ ┴   ↑ ┴   ↑ ┴   ↑ ┘
```

2. 遍历个位上的值 `i`, 然后 `count[i]++`, 得出个位上各个值出现的频次如下:
```
             ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
    t_count: │     │  1  │  1  │  2  │     │  1  │     │  1  │     │     │   没有写的默认就是 0
             └  0  ┴  1  ┴  2  ┴  3  ┴  4  ┴  5  ┴  6  ┴  7  ┴  8  ┴  9  ┘
设 count 下标为 i, i 位置上的元素为 a 的含义为:
    数组 arr 中"个位"上值 == i 的数量
```

3. 然后对 count 数组求前缀和, 即 `count[i] += count[i-1]`
```
           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
    count: │  0  │  1  │  2  │  4  │  4  │  5  │  5  │  6  │  6  │  6  │
           └  0  ┴  1  ┴  2  ┴  3  ┴  4  ┴  5  ┴  6  ┴  7  ┴  8  ┴  9  ┘
此时 count 数组中, 下标 i 上的元素 a 含义变为:
    数组 arr 中"个位"上值 <= i 的数量
```

基数排序 2 中的辅助数组 `help` 计算方式如下:
- 从右到左遍历数组 `arr` 上指定位的值, 比如当前数 `num` 的个位上的值为 `i`
- 然后以 `i` 为 count 下标, 将对应位置上的值减 1 得到 a, 即 `a = --count[i]`
- 最后将 `num` 放到 `help` 数组的下标 `a` 位置上, 即 `help[a] = num`
- 重复上面过程, 直到遍历完数组 `arr`, 此时相当于完成了一次 入桶出桶 操作
- 完成后记得将 `help` 拷贝到 `arr` 数组中。

举个🌰:

```
要排序的数组 arr
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    arr:    │ 017 │ 013 │ 025 │ 101 │ 033 │ 072 │
            └─────┴─────┴─────┴─────┴─────┴─────┘
定义 help 数组, 它的大小和 arr 相同:
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │     │     │     │     │     │
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  这里的值是数组下标

按照前面的步骤, 先遍历个位上的数, 求出 count 数组:
           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
    count: │  0  │  1  │  2  │  4  │  4  │  5  │  5  │  6  │  6  │  6  │
           └  0  ┴  1  ┴  2  ┴  3  ┴  4  ┴  5  ┴  6  ┴  7  ┴  8  ┴  9  ┘

从右到左遍历 arr 数组, 比如遇到 72, 个位上是 2, 所以将 count[2]--,
得到 count[2] 的值为 1, 于是将 72 放到 help[1] 上
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    arr:    │ 017 │ 013 │ 025 │ 101 │ 033 │ 072 │
            └   ↑  ←  ↑  ←  ↑  ←  ↑  ←  ↑  ←  ↑ ┘
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │ 072 │     │     │     │     │    72, count[2]--;   count[2] = 1
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘     ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │ 072 │     │ 033 │     │     │    33, count[3]--;   count[3] = 3
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘     ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │ 101 │ 072 │     │ 033 │     │     │   101, count[1]--;   count[1] = 0
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘     ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │ 101 │ 072 │     │ 033 │ 025 │     │    25, count[5]--;   count[5] = 4
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘     ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │ 101 │ 072 │ 013 │ 033 │ 025 │     │    13, count[3]--;    count[3] = 2
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘     ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │ 101 │ 072 │ 013 │ 033 │ 025 │ 017 │    17, count[7]--;    count[7] = 5
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘     ↑

此时成功完成一次进出桶操作, 将 help 拷贝到 arr 中:
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    arr:    │ 101 │ 072 │ 013 │ 033 │ 025 │ 017 │
            └─────┴─────┴─────┴─────┴─────┴─────┘
```

后面的工作和前面一样, 再继续求取各个位上的数, 然后更新 arr 数组:
```
对十位上的数执行进出桶:
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    arr:    │ 101 │ 072 │ 013 │ 033 │ 025 │ 017 │
            └──↑──┴──↑──┴──↑──┴──↑──┴──↑──┴──↑──┘
           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
  t_count: │  1  │  2  │  1  │  1  │     │     │     │  1  │     │     │
           └  0  ┴  1  ┴  2  ┴  3  ┴  4  ┴  5  ┴  6  ┴  7  ┴  8  ┴  9  ┘
           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
    count: │  1  │  3  │  4  │  5  │  5  │  5  │  5  │  6  │  6  │  6  │
           └  0  ┴  1  ┴  2  ┴  3  ┴  4  ┴  5  ┴  6  ┴  7  ┴  8  ┴  9  ┘
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
            │ 101 │ 072 │ 013 │ 033 │ 025 │ 017 │
            └  ↑   ← ↑   ← ↑   ← ↑   ← ↑   ← ↑  ┘
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │     │ 017 │     │     │     │  17, count[1]--; count[1] = 2
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │     │ 017 │ 025 │     │     │  25, count[2]--; count[2] = 3
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │     │ 017 │ 025 │ 033 │     │  33, count[3]--; count[3] = 4
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │ 013 │ 017 │ 025 │ 033 │     │  13, count[1]--; count[1] = 1
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │ 013 │ 017 │ 025 │ 033 │ 072 │  72, count[7]--; count[7] = 5
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │ 101 │ 013 │ 017 │ 025 │ 033 │ 072 │ 101, count[0]--; count[7] = 0
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    arr:    │ 101 │ 013 │ 017 │ 025 │ 033 │ 072 │
            └─────┴─────┴─────┴─────┴─────┴─────┘


对百位上的数执行进出桶:
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    arr:    │ 101 │ 013 │ 017 │ 025 │ 033 │ 072 │
            └─↑───┴─↑───┴─↑───┴─↑───┴─↑───┴─↑───┘
           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
  t_count: │  5  │  1  │     │     │     │     │     │     │     │     │
           └  0  ┴  1  ┴  2  ┴  3  ┴  4  ┴  5  ┴  6  ┴  7  ┴  8  ┴  9  ┘
           ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
    count: │  5  │  6  │  6  │  6  │  6  │  6  │  6  │  6  │  6  │  6  │
           └  0  ┴  1  ┴  2  ┴  3  ┴  4  ┴  5  ┴  6  ┴  7  ┴  8  ┴  9  ┘
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
            │ 101 │ 013 │ 017 │ 025 │ 033 │ 072 │
            └ ↑    ←↑    ←↑    ←↑    ←↑    ←↑   ┘
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │     │     │     │ 072 │     │  072, count[0]--; count[0] = 4
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │     │     │ 033 │ 072 │     │  033, count[0]--; count[0] = 3
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │     │ 025 │ 033 │ 072 │     │  025, count[0]--; count[0] = 2
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │     │ 017 │ 025 │ 033 │ 072 │     │  017, count[0]--; count[0] = 1
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │ 013 │ 017 │ 025 │ 033 │ 072 │     │  013, count[0]--; count[0] = 0
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    help:   │ 013 │ 017 │ 025 │ 033 │ 072 │ 101 │  101, count[1]--; count[1] = 5
            └──0──┴──1──┴──2──┴──3──┴──4──┴──5──┘  ↑
            ┌─────┬─────┬─────┬─────┬─────┬─────┐
    arr:    │ 013 │ 017 │ 025 │ 033 │ 072 │ 101 │
            └─────┴─────┴─────┴─────┴─────┴─────┘
END
```
