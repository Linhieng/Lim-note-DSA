## ğŸ• æ€»ç»“æ’åº(æ—¶é—´å¤æ‚åº¦, ç©ºé—´å¤æ‚åº¦, ç¨³å®šæ€§)

| æ’åºç®—æ³•(å…¸å‹)   | æ—¶é—´å¤æ‚åº¦(é€šå¸¸æƒ…å†µ) | (é¢å¤–)ç©ºé—´å¤æ‚åº¦(é€šå¸¸æƒ…å†µ) | ç¨³å®šæ€§(é€šå¸¸æƒ…å†µ) |
|---------------|----------------------|----------------------------|----------------|
| é€‰æ‹©æ’åº         | $O(N^2)$             | $O(1)$                     | âŒä¸ç¨³å®š          |
| å†’æ³¡æ’åº         | $O(N^2)$             | $O(1)$                     | âœ”ï¸ç¨³å®š           |
| æ’å…¥æ’åº         | $O(N^2)$             | $O(1)$                     | âœ”ï¸ç¨³å®š           |
| **å½’å¹¶æ’åº**     | $O(N * logN)$        | $O(N)$                     | âœ”ï¸ç¨³å®š           |
| **éšæœºå¿«é€Ÿæ’åº** | $O(N * logN)$        | $O(logN)$                  | âŒä¸ç¨³å®š          |
| **å †æ’åº**       | $O(N * logN)$        | $O(1)$                     | âŒä¸ç¨³å®š          |
| è®¡æ•°æ’åº         | $O(N)$               | $O(N)$                     | âœ”ï¸ç¨³å®š           |
| åŸºæ•°æ’åº         | $O(N)$               | $O(N)$                     | âœ”ï¸ç¨³å®š           |

### ç¨³å®šæ€§

ç¨³å®šå°±æ˜¯: å½“å­˜åœ¨ç›¸ç­‰å…ƒç´ æ—¶, æ’åºåå®ƒä»¬çš„ç›¸å¯¹é¡ºåºä¸å˜ã€‚

- é€‰æ‹©æ’åº: æ¯æ¬¡é€‰æ‹©æœ€å°çš„æ•°ä¸ç¬¬ä¸€ä¸ªæ•°äº¤æ¢ã€‚
    - æ’åºåä¸ç¨³å®šğŸŒ°:
        - [ $3_a$, $3_b$, 1 ]
        - [ 1, $3_b$, $3_a$ ] ç¬¬ä¸€è½®éå†æ—¶, é€‰åˆ°æœ€å°å€¼ 1, å°†å®ƒä¸ç¬¬ä¸€ä¸ªæ•°äº¤æ¢
        - å¾ˆæ˜æ˜¾, æ’åºåçš„ $3_b$ å’Œ $3_a$ ä½ç½®äº’æ¢äº†ã€‚

- å†’æ³¡æ’åº: å¦‚æœå·¦å€¼ > å³å€¼, å°±äº¤æ¢ã€‚
    - æ’åºåç¨³å®šğŸŒ°:
        - [ $3_a$, $3_b$, 1 ]
        - [ $3_a$, 1, $3_b$ ]
        - [ 1, $3_a$, $3_b$ ]
    - æ³¨æ„âš ï¸, å¦‚æœå†’æ³¡æ’åºçš„å®ç°å†™æˆå·¦å€¼ >= å³å€¼æ—¶äº¤æ¢, åˆ™å†’æ³¡æ’åºä¼šå˜æˆä¸ç¨³å®šï¼š
        - [ $3_a$, $3_b$ ]
        - [ $3_b$, $3_a$ ] å› ä¸ºæ­¤æ—¶å·¦å€¼ == å³å€¼, æ‰€ä»¥è¿˜ä¼šç»§ç»­äº¤æ¢, æ­¤æ—¶å°±ä¼šå¯¼è‡´ä¸ç¨³å®š

- æ’å…¥æ’åº: å½“å·¦å€¼ >= å³å€¼æ—¶, åœæ­¢æ’å…¥(äº¤æ¢)ã€‚
    - æ’åºåç¨³å®šğŸŒ°:
        - [ $3_a$, $3_b$, 1 ]
        - [ $3_a$, 1, $3_b$ ]
        - [ 1, $3_a$, $3_b$ ]
    - åŒæ ·æ³¨æ„âš ï¸, å¦‚æœå½“ä¸¤ä¸ªå€¼ç›¸ç­‰æ—¶, è¿˜è¦ç»§ç»­æ’å…¥, åˆ™ä¼šå˜æˆä¸ç¨³å®šï¼š
        - [ $3_a$, 1, $3_b$ ]
        - [ 1, $3_a$, $3_b$ ] æ’å¥½ 1
        - [ 1, $3_a$, $3_b$ ] æ’å¥½ $3_a$
        - [ 1, $3_b$, $3_a$ ] æ’å¥½ $3_b$

- å½’å¹¶æ’åº: å…ˆäºŒåˆ†åä¾æ¬¡æ’åº, ç„¶ååˆå¹¶ã€‚ åˆå¹¶è¿‡ç¨‹ä¸­è‹¥ä¸¤ä¸ªæ•°ç›¸ç­‰, å…ˆåˆå¹¶å·¦è¾¹
    - æ’åºåç¨³å®šğŸŒ°:
        - merge [ 1, $3_a$ ]  [ $3_b$ ]
        - merge result: [ 1 ]
        - merge result: [ 1, $3_a$ ]
        - merge result: [ 1, $3_a$, $3_b$ ]
    - åŒæ ·æ³¨æ„âš ï¸, å¦‚æœå…ˆåˆå¹¶å³è¾¹, åˆ™ä¼šä¸ç¨³å®šã€‚ è€Œå‰é¢ä»‹ç»è¿‡çš„ "å°å’Œé—®é¢˜", å°±æ˜¯å…ˆåˆå¹¶å³è¾¹çš„, æ‰€ä»¥é‚£æ—¶çš„å½’å¹¶æ˜¯ä¸ç¨³å®šçš„
        - merge [ 1, $3_a$ ]  [ $3_b$ ]
        - merge result: [ 1 ]
        - merge result: [ 1, $3_b$ ]
        - merge result: [ 1, $3_b$, $3_a$ ]

- å¿«é€Ÿæ’åº: ä¸æ–­çš„éšæœºé€‰å– pivot(åˆ’åˆ†å€¼), ç„¶åæ‰§è¡Œ partitionã€‚partition æ ¸å¿ƒ: å°†æ•°å€¼åˆ’åˆ†è¿›å¯¹åº”åŒºåŸŸã€‚ æ¯”å¦‚, å°† < pivot çš„å€¼åˆ’åˆ†è¿› "< åŒº", å…·ä½“åšæ³•æ˜¯å°†è¯¥å€¼åŸŸ "< åŒº" è¾¹ç•Œäº¤æ¢, ç„¶åæ‰©å¤§è¾¹ç•Œã€‚
    - æ’åºåä¸ç¨³å®šğŸŒ°:
        - [ $3_a$, $3_b$, 1 ], é€‰å–çš„ pivot æ˜¯ 2
        - [ 1, $3_b$, $3_a$ ], è¯†åˆ«åˆ° 1 æ—¶, å°†å®ƒä¸ "< åŒº" çš„è¾¹ç•Œ+1 å€¼äº¤æ¢, æ•… $3_a$ è·¨è¿‡äº† $3_b$
    - ä¸ç®¡æ˜¯äºŒé¡¹åˆ’åˆ†è¿˜æ˜¯ä¸‰é¡¹åˆ’åˆ†, ç»“æœéƒ½æ˜¯ä¸ç¨³å®šçš„ã€‚


- å †æ’åº: åˆ©ç”¨å †çš„ç‰¹æ€§(å¯ä»¥æ˜¯å¤§æ ¹å †æˆ–å°æ ¹å †)è¿›è¡Œæ’åº
    - åœ¨æ„é€ å †çš„è¿‡ç¨‹ä¸­å°±å·²ç»æ‰“ä¹±äº†é¡ºåº, ä¸¾ä¸ªå°æ ¹å †æ‰“ä¹±ğŸŒ°:
        - åŸæ•°ç»„: [ $3_a$, $3_b$, 1 ]
        - å¯¹ 1 è¿›è¡Œ heap insert (æˆ–è€…å¯¹ $3_a$ è¿›è¡Œ heapify) çš„è¿‡ç¨‹ä¸­, å°†ä¼šäº¤æ¢ 1 å’Œ $3_a$ çš„ä½ç½®, ç»“æœå¦‚ä¸‹
        - å°æ ¹å †: [ 1, $3_b$, $3_a$ ]

- è®¡æ•°æ’åº, åŸºæ•°æ’åº, ä»–ä»¬çš„ç®—æ³•æ€è·¯æœ¬èº«å°±ä¸æ˜¯åŸºäºæ¯”è¾ƒçš„, ä»–ä»¬æ˜¯åˆ©ç”¨ "æ¡¶" çš„ç»“æ„æ¥å®ç°æ’åºçš„, æ‰€ä»¥åªè¦ç¡®ä¿ "å…¥æ¡¶" å’Œ "å‡ºæ¡¶" çš„è¿‡ç¨‹ä¸­å…ƒç´ çš„ç›¸å¯¹é¡ºåºä¸å˜, é‚£ä¹ˆä»–ä»¬å°±æ˜¯ç¨³å®šçš„

### æ€»ç»“

å‰é¢çš„å‡ ç§æ’åº, å¯ä»¥åˆ†ä¸ºä¸‰å¤§ç±», é€‰æ‹©å†’æ³¡æ’å…¥ä½œä¸ºä¸€ç±», å½’å¹¶å¿«æ’å †ä½œä¸ºä¸€ç±», è®¡æ•°åŸºæ•°ä½œä¸ºä¸€ç±»ã€‚
å¯¹äºè®¡æ•°å’ŒåŸºæ•°æ’åº, åªé€‚ç”¨äºç‰¹å®šæƒ…å†µã€‚
é€‰æ‹©å†’æ³¡æ’å…¥æ’åº, å¯ä»¥ä½œä¸ºç®€å•æ’åºç®—æ³•çš„å­¦ä¹ , åªé€‚ç”¨ç®€å•æ•°æ®ã€‚
å½’å¹¶å¿«æ’å †æ’åº, é€‚ç”¨èŒƒå›´æœ€å¹¿ã€‚

å½’å¹¶, å¿«æ’, å † å¦‚ä½•é€‰å–?
- ä¸€èˆ¬éƒ½æ˜¯é€‰æ‹© **éšæœºå¿«æ’** è¿›è¡Œæ’åºã€‚ è™½ç„¶å¿«æ’å’Œå †çš„æ—¶é—´å¤æ‚åº¦ç›¸åŒ, ä½†å®è·µè¿‡ç¨‹ä¸­å‘ç°å¿«æ’çš„å¸¸æ•°æ—¶é—´æ›´çŸ­ã€‚
- å½“æœ‰ç¨³å®šæ€§éœ€æ±‚æ—¶, é€‰æ‹©å½’å¹¶æ’åº
- å½“è¦å‹æ¦¨ç©ºé—´æ—¶, é€‰æ‹©å †æ’åº

æ’åºç®—æ³•å¸¸è§çš„å‘
- å½’å¹¶æ’åºçš„é¢å¤–ç©ºé—´å¤æ‚åº¦å¯ä»¥å˜æˆ O(1)ã€‚â€”â€” éå¸¸éš¾å®ç°, ä¸éœ€è¦æŒæ¡ã€‚æœ‰å…´è¶£å¯ä»¥æœç´¢"å½’å¹¶æ’åº å†…éƒ¨ç¼“å­˜æ³•"ã€‚ è€Œä¸”è™½ç„¶ç©ºé—´å¤æ‚åº¦é™äº†, ä½†åŒæ—¶å®ƒä¹Ÿå˜å¾—ä¸ç¨³å®šäº†, é‚£ä¸ºä»€ä¹ˆä¸ç”¨å †æ’åºå‘¢?
- åŸåœ°å½’å¹¶æ’åºå¯ä»¥å®ç°ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚â€”â€” è™½ç„¶ç©ºé—´å¤æ‚åº¦é™ä½äº†, ä½†å®ƒçš„æ—¶é—´å¤æ‚åº¦å˜æˆäº† O(N^2), é‚£ä¸ºä»€ä¹ˆä¸ç”¨ç®€å•æ’åºå‘¢
- å¿«é€Ÿæ’åºå¯ä»¥åšåˆ°ç¨³å®šã€‚ â€”â€” éš¾ã€‚ è€Œä¸”è™½ç„¶åšåˆ°äº†ç¨³å®šæ€§, ä½†ç©ºé—´å¤æ‚åº¦ä¼šå˜æˆ O(N), é‚£ä¸ºä»€ä¹ˆä¸ç”¨å½’å¹¶æ’åºå‘¢? æœ‰å…´è¶£å¯ä»¥æœç´¢ "01 stable sort"ã€‚
- é¢è¯•é¢˜: è¦æ±‚å¥‡æ•°æ”¾åœ¨æ•°ç»„å·¦è¾¹, å¶æ•°æ”¾åœ¨æ•°ç»„å³è¾¹, åŒæ—¶ç›¸å¯¹æ¬¡åºä¸å˜, å¹¶ä¸”æ—¶é—´å¤æ‚åº¦ä¸º O(N), ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚
    - å›ç­”: ç»å…¸çš„å¿«æ’åšä¸åˆ°ç¨³å®šæ€§, è€Œç»å…¸å¿«æ’çš„ partition åˆæ˜¯ 01 æ ‡å‡†çš„, å®ƒå’Œè¿™ä¸ªå¥‡å¶é—®é¢˜å…¶å®æ˜¯ä¸€ç§è°ƒæ•´ç­–ç•¥, å¿«æ’åšä¸åˆ°, æ‰€ä»¥æˆ‘ä¹Ÿä¸çŸ¥é“æ€ä¹ˆåšã€‚ ç„¶åæŠŠé—®é¢˜åæŠ›ç»™é¢è¯•å®˜ã€‚
    - partition è¿‡ç¨‹, èƒ½å¤Ÿå°† "â‰¤ pivot" çš„æ”¾å·¦è¾¹, "> pivot" çš„æ”¾å³è¾¹, è¿™å…¶å®å°±æ˜¯ "01æ ‡å‡†"ã€‚ å®ƒèƒ½åšåˆ°æ—¶é—´å¤æ‚åº¦ O(N), ç©ºé—´å¤æ‚åº¦ O(1), ä½†å®ƒåšä¸åˆ°ç¨³å®šã€‚ æ‰€ä»¥è¿™é“é¢è¯•é¢˜ç›®å‰æ˜¯æ— è§£çš„ã€‚

### å·¥ç¨‹ä¸Šå¯¹æ’åºçš„æ”¹è¿›

- å……åˆ†åˆ©ç”¨ O(N*logN) å’Œ O(N^2) å„è‡ªçš„ä¼˜åŠ¿ã€‚
æ¯”å¦‚åœ¨å¤§æ•°æ®é‡çš„æ—¶å€™ä½¿ç”¨å¿«æ’, åœ¨å°æ•°æ®é‡çš„æ—¶å€™ä½¿ç”¨æ’å…¥ã€‚ æ‰€ä»¥åœ¨å¿«æ’çš„ä»£ç ä¸Š, ç»å¸¸ä¼šçœ‹åˆ°åœ¨æ’åºå‰, å…ˆç”¨ if åˆ¤æ–­ä¸€ä¸‹å¾…æ’åºçš„æ•°æ®, å¦‚æœå°äºä¸€å®š 60 ä¸ª, åˆ™ä½¿ç”¨çš„æ˜¯æ’å…¥æ’åºã€‚ã€€

- ç¨³å®šæ€§é—®é¢˜ã€‚
å¯¹äºåŸºæœ¬æ•°æ®, ä¸éœ€è¦è€ƒè™‘ç¨³å®šæ€§é—®é¢˜ã€‚ æ¯”å¦‚ç³»ç»Ÿæä¾›çš„æ’åºé»‘ç›’, å½“æ•°æ®æ˜¯åŸºæœ¬ç±»å‹æ—¶, å®ƒä¼šä½¿ç”¨å¿«æ’ã€‚ ä½†æ•°æ®æ˜¯å¯¹è±¡æ—¶, å®ƒä¼šä½¿ç”¨å½’å¹¶ã€‚


## ğŸ• ç®€å•äº†è§£å“ˆå¸Œè¡¨

å“ˆå¸Œè¡¨æœ‰ä¸¤ç§, Map å’Œ Set, è¿™ä¸¤ç§æœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ã€‚ Map æ˜¯ key-value çš„å½¢å¼, Set æ˜¯åªæœ‰ key çš„å½¢å¼ã€‚

å“ˆå¸Œè¡¨çš„å¢åˆ æ”¹æŸ¥æ“ä½œéƒ½æ˜¯ O(1) çº§åˆ«çš„ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯, å“ˆå¸Œè¡¨çš„å¸¸æ•°æ—¶é—´æ˜¯æ¯”è¾ƒå¤§çš„, å®ƒç›¸æ¯”æ•°ç»„å¯»å€è‚¯å®šæ˜¯æ¯”è¾ƒæ…¢ä¸€ç‚¹çš„ã€‚

æ³¨æ„ä¸€ä¸ªæ¦‚å¿µï¼š å€¼ä¼ é€’è¿˜æ˜¯å¼•ç”¨ä¼ é€’ã€‚ é€šå¸¸æƒ…å†µæ˜¯, å“ˆå¸Œè¡¨çš„è§„åˆ™æ˜¯:
- å½“ key ç±»å‹æ˜¯åŸºç¡€ç±»å‹æ—¶, å“ˆå¸Œè¡¨å†…éƒ¨æ˜¯å€¼ä¼ é€’çš„; æ­¤æ—¶å“ˆå¸Œè¡¨å†…éƒ¨ä¼šå¼€è¾Ÿä¸€å—ç©ºé—´å­˜å‚¨å…·ä½“çš„å€¼, è¿™å—ç©ºé—´çš„å¤§å°ç”±å…·ä½“çš„å€¼å†³å®šã€‚
- å½“ key ç±»å‹æ˜¯å¤æ‚ç±»å‹æ—¶, å“ˆå¸Œè¡¨å†…éƒ¨æ˜¯å¼•ç”¨ä¼ é€’æ—¶; æ­¤æ—¶å“ˆå¸Œè¡¨å†…éƒ¨åªä¼šå­˜å‚¨å¼•ç”¨, ä¸ä¼šé‡æ–°æ‹·è´ä¸€ä»½æ•°æ®ã€‚ å¼•ç”¨æ‰€å ç”¨çš„ç©ºé—´çš„å¤§å°æ˜¯å›ºå®šçš„ã€‚

> java ä¸­çš„å“ˆå¸Œè¡¨æ˜¯ HashSet, HashMap ç»“æ„
> C++ ä¸­çš„å“ˆå¸Œè¡¨æ˜¯ UnorderedSet, UnorderedMap ç»“æ„


## ğŸ• ç®€å•äº†è§£æœ‰åºè¡¨

æœ‰åºè¡¨å’Œå“ˆå¸Œè¡¨ç±»ä¼¼, ä¹Ÿæœ‰ Map å’Œ Set ä¸¤ç§ã€‚
åªä¸è¿‡æœ‰åºè¡¨å®ç°äº†å¯¹ key è¿›è¡Œæ’åºã€‚ æ‰€ä»¥å¯ä»¥æŒ‰ç…§ç‰¹å®šé¡ºåºè·å–æœ‰åºè¡¨ä¸­çš„ key-valueã€‚
æ³¨æ„, å¦‚æœä¼ é€’ç»™æœ‰åºè¡¨çš„ key æ— æ³•ç›´æ¥æ¯”è¾ƒ, åˆ™éœ€è¦ä¼ é€’æ¯”è¾ƒå™¨ã€‚

æœ‰åºè¡¨çš„å¢åˆ æ”¹æŸ¥æ“ä½œéƒ½æ˜¯ O(logN) çº§åˆ«çš„ã€‚

çº¢é»‘æ ‘, AVL æ ‘, size-balance-tree å’Œè·³è¡¨ç­‰éƒ½å±äºæœ‰åºè¡¨ç»“æ„ã€‚ åªæ˜¯åº•å±‚å…·ä½“å®ç°ä¸åŒã€‚

> java ä¸­çš„æœ‰åºè¡¨æ˜¯ TreeSet, TreeMap ç»“æ„
> C++ ä¸­çš„æœ‰åºè¡¨æ˜¯ OrderedSet, OrderedMap ç»“æ„

## ğŸ• é“¾è¡¨

é“¾è¡¨åˆ†ä¸ºå•é“¾è¡¨å’ŒåŒé“¾è¡¨:
- å•é“¾è¡¨: å•å‘è¿æ¥
- åŒé“¾è¡¨: åŒå‘è¿æ¥

### å°ç»ƒä¹  - åè½¬é“¾è¡¨

é¢˜ç›®: åˆ†åˆ«å®ç°åè½¬å•é“¾è¡¨å’Œåè½¬åŒé“¾è¡¨çš„å‡½æ•°ã€‚
è¦æ±‚: å¦‚æœé“¾è¡¨é•¿åº¦ä¸º N, è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸º O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚

ã€âš ï¸é‡ç‚¹ã€‘ï¼š å½“ä½ æ–­æ‰æŸä¸ªé“¾æ¡æ—¶, ä½ è¦æ¸…æ¥šæ˜¯å¦éœ€è¦ä½¿ç”¨åˆ°æ–­å¼€ä¹‹å‰æ‰€æŒ‡å‘çš„èŠ‚ç‚¹! å¦‚æœéœ€è¦, é‚£ä¹ˆä¸€å®šè¦å…ˆå°†è¯¥èŠ‚ç‚¹å­˜å‚¨èµ·æ¥ï¼

ã€ä»£ç ã€‘ï¼š

```py
def reversed_linked_list(head, is_double=False):
    # åˆ¤æ–­è¾¹ç•Œæ¡ä»¶
    if head is None or head.next is None:
        return head

    # åˆå§‹å€¼
    pr = None
    p = head
    pn = p.next

    while True:
        p.next = pr # åè½¬
        if is_double:
            p.prev = pn # åè½¬åŒé“¾è¡¨åªå¤šäº†è¿™ä¸€æ­¥

        # ç»“æŸåˆ¤æ–­
        if pn is None:
            break

        # æ›´æ–°
        pr = p
        p = pn
        pn = p.next

    return p
```


### å°ç»ƒä¹  - æ‰“å°ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„å…¬å…±éƒ¨åˆ†

ã€é¢˜ç›®ã€‘: ç»™å®šä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„å¤´æŒ‡é’ˆ head1 å’Œ head2, æ‰“å°ä¸¤ä¸ªé“¾è¡¨çš„å…¬å…±éƒ¨åˆ†ã€‚
ã€è¦æ±‚ã€‘: å¦‚æœä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ä¹‹å’Œä¸º N, æ—¶é—´å¤æ‚åº¦è¦æ±‚ä¸º O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦è¦æ±‚ä¸º O(1)ã€‚

ã€ç®—æ³•æ€è·¯ã€‘: ä¸¤ä¸ªæŒ‡é’ˆ, è°å°è°ç§»åŠ¨ã€‚ ç›¸åŒæ—¶æ‰“å°å¹¶ä¸€èµ·ç§»åŠ¨ã€‚ ç›´åˆ°æŸä¸€æŒ‡é’ˆè¶Šç•Œã€‚

ã€ä»£ç ã€‘:
```py
def linked_list_common(head1, head2):
    common = []
    while head1 is not None and head2 is not None:
        if head1.data < head2.data:
            head1 = head1.next
        elif head1.data > head2.data:
            head2 = head2.next
        else:
            common.append(head1.data)
            head1 = head1.next
            head2 = head2.next
    return common
```

### é¢è¯•æ—¶é“¾è¡¨è§£é¢˜æ–¹æ³•è®º

ç¬”è¯•å’Œé¢è¯•è¦æ±‚ä¸ä¸€æ ·ã€‚
- ç¬”è¯•: èƒ½è¿‡å°±è¡Œ, æ²¡äººçœ‹ä½ ä»£ç ã€‚ æ‰€ä»¥ä¸ç”¨å¤ªåœ¨ä¹ç©ºé—´å¤æ‚åº¦, ä¸€åˆ‡ä¸ºäº†æ—¶é—´å¤æ‚åº¦ã€‚
- é¢è¯•: æ—¶é—´å¤æ‚åº¦ä»ç„¶æ˜¯ç¬¬ä¸€ä½, ä½†æ˜¯ç©ºé—´å¤æ‚åº¦ä¸€å®šè¦çœã€‚ å› ä¸ºæ­¤æ—¶çœ‹ä½ çš„ä¸æ˜¯æœºå™¨, æ˜¯é¢è¯•å®˜ã€‚

æŠ€å·§:
- é¢å¤–æ•°æ®ç»“æ„è®°å½•(å“ˆå¸Œè¡¨ç­‰)
- å¿«æ…¢æŒ‡é’ˆã€‚ æ¯”å¦‚ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸€æ­¥, ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸¤æ­¥ã€‚

### ç»ƒä¹  - åˆ¤æ–­å•é“¾è¡¨å›æ–‡

ã€åšæ³•1(ç¬”è¯•)ã€‘: å…ˆéå†ä¸€éé“¾è¡¨, å¹¶æŠŠå€¼ä¾æ¬¡æ”¾å…¥æ ˆä¸­ã€‚ å†éå†ä¸€éé“¾è¡¨, æ­¤æ—¶æ¯æ¬¡éå†éƒ½å°†æ ˆçš„å†…å®¹å¼¹å‡º, ç„¶åæ¯”è¾ƒæ˜¯å¦ç›¸ç­‰ã€‚ ç›´åˆ°ä¸ç›¸ç­‰æˆ–è€…æ ˆä¸ºç©ºã€‚

ã€åšæ³•2(ç¬”è¯•)ã€‘: èƒ½ä¸èƒ½ä¼˜åŒ–åšæ³•1?
åšæ³• 1 ä¸­éå†äº†ä¸¤éé“¾è¡¨, è€Œä¸”æ ˆå ç”¨çš„ç©ºé—´å¤§å°ä¸º Nã€‚
ä½†å®é™…ä¸Š, å½“æˆ‘ä»¬éå†åˆ°é“¾è¡¨ä¸­é—´ä¹‹å, å°±å¯ä»¥å°†æ ˆä¸­çš„å…ƒç´  pop å‡ºæ¥å’Œé“¾è¡¨è¿›è¡Œæ¯”è¾ƒäº†ã€‚
é—®é¢˜åœ¨äº, å¦‚ä½•ç¡®å®šä¸­é—´ä½ç½®? æ–¹æ³•å°±æ˜¯ **å¿«æ…¢æŒ‡é’ˆ**ã€‚
ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸€æ­¥, ä¸€ä¸ªæŒ‡é’ˆèµ°ä¸¤æ­¥ã€‚ å½“å¿«æŒ‡é’ˆåˆ°å¤´æ—¶, å°±è¯´æ˜åˆ°ä¸­é—´äº†ã€‚

ã€åšæ³•3(é¢è¯•)ã€‘: èƒ½ä¸èƒ½ç»§ç»­ä¼˜åŒ–åšæ³•2?
èƒ½, å¯ä»¥ä»…ä»…ä½¿ç”¨å‡ ä¸ªå˜é‡å°±è§£å†³ã€‚ æ­¥éª¤å¦‚ä¸‹:
1. è®°ä½èµ·ç‚¹ä½ç½® a
2. é€šè¿‡å¿«æ…¢æŒ‡é’ˆ, å¿«æŒ‡é’ˆåˆ°å¤´æ—¶, è®°ä¸‹ä¸­é—´ä½ç½® b å’Œç»ˆç‚¹ä½ç½® cã€‚
3. æ…¢æŒ‡é’ˆç»§ç»­å¾€ä¸‹èµ°, ä½†èµ°çš„è¿‡ç¨‹ä¸­å°†ååŠéƒ¨åˆ†çš„é“¾è¡¨åè½¬
4. æ…¢æŒ‡é’ˆåˆ°å¤´æ—¶, ååŠéƒ¨åˆ†é“¾è¡¨åè½¬å®Œæˆ, æ­¤æ—¶ç»ˆç‚¹ c ä½ç½®å¯ä»¥å¾€å‰éå†
5. c å¾€å‰éå†, a å¾€åéå†, ä¾æ¬¡åˆ¤æ–­æ˜¯å¦å›æ–‡ã€‚
6. c åœ¨å¾€å‰éå†æ—¶, å†æ¬¡å°†ååŠéƒ¨åˆ†çš„é“¾è¡¨åè½¬ã€‚
è¿™ç§æ–¹å¼ä¸‹, èµ°äº†ä¸€åœˆåŠ, ä½†ç©ºé—´å¤æ‚åº¦è¾¾åˆ°äº†å¸¸æ•°çº§åˆ«ã€‚

ã€æ³¨æ„âš ï¸ã€‘: æ€è·¯éƒ½å¾ˆç®€å•, éœ€è¦æ³¨æ„çš„åªæœ‰é•¿åº¦å¥‡å¶æ•°æƒ…å†µä¸‹, ä¸­ç‚¹çš„é€‰å–ã€‚ æ ¹æ®é¢˜æ„çš„ä¸åŒ, é€‰å–çš„æ–¹å¼ä¹Ÿä¸åŒã€‚

#### è€å¸ˆä»£ç 

```java
// æ–¹æ³•1
public static boolean isPalindrome1(Node head) {
    Stack<Node> stack = new Stack<Node>();
    Node cur = head;
    // å°†é“¾è¡¨æ‰€æœ‰èŠ‚ç‚¹å…¥æ ˆ
    while (cur != null) {
        stack.push(cur);
        cur = cur.next;
    }
    // å†æ¬¡éå†é“¾è¡¨, å¹¶ä»æ ˆä¸­å…ƒç´ ä¸€ä¸€æ¯”è¾ƒ
    while (head != null) {
        if (head.value != stack.pop().value) {
            return false;
        }
        head = head.next;
    }
    return true;
}

// æ–¹æ³•2
public static boolean isPalindrome2(Node head) {
    if (head == null || head.next == null) {
        return true;
    }
    Node right = head.next;
    Node cur = head;
    // æ‰¾åˆ°ä¸­ç‚¹ä½ç½®
    while (cur.next != null && nul.next.next != null) {
        right = right.next;
        cur = cur.next.next;
    }
    // ä»ä¸­ç‚¹ä½ç½®å†å¼€å§‹å°†å…ƒç´ å…¥æ ˆ
    Stack<Node> stack = new Stack<Node>();
    while (right != null) {
        stack.push(right);
        right = right.next;
    }
    // å†æ¬¡éå†, ä¸€ä¸€æ¯”è¾ƒ
    while (!stack.isEmpty()) {
        if (head.value != stack.pop().value) {
            return false;
        }
        head = head.next;
    }
}

// æ–¹æ³•3
public static boolean isPalindrome3(Node head) {
    if (head == null || head.next == null) {
        return true;
    }
    Node n1 = head;
    Node n2 = head;
    // å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­é—´
    while (n2.next != null && n2.next.next != null) {
        n1 = n1.next;
        n2 = n2.next.next;
    }
    // åè½¬ååŠé“¾è¡¨
    n2 = n1.next;
    n1.next = null;
    Node n3 = null;
    while (n2 != null) {
        n3 = n3.next;
        n2.next = n1;
        n2 = n3;
    }
    // ä»é“¾è¡¨ä¸¤ç«¯å‘ä¸­é—´ä¸€ä¸€æ¯”è¾ƒ
    n3 = n1;
    n2 = head;
    boolean res = true;
    while (n1 != null && n2 != null) {
        if (n1.value != n2.value) {
            res = false;
            break;
        }
        n1 = n1.next;
        n2 = n2.next;
    }
    // å®Œæˆåå†æ¬¡æŠŠååŠé“¾è¡¨åè½¬
    n1 = n3.next;
    n3.next = null;
    while (n1 != null) {
        n2 = n1.next;
        n1.next = n3;
        n3 = n1;
        n1 = n2;
    }
}

```

#### æˆ‘çš„ä»£ç 


```py
def is_palindrome_linked_list2(head):
    if head is None:
        return False
    if head.next is None:
        return True
    # åˆ©ç”¨å¿«æ…¢æŒ‡é’ˆ, èµ°åˆ°ä¸­ç‚¹å°±å¼€å§‹å‡ºæ ˆæ¯”è¾ƒ
    slow = head
    quick = head.next
    mid_r = None  # å¶:åå³; å¥‡:ä¸­ç‚¹å³è¾¹
    half_stack = []  # åªä¼šå¡«å……å·¦ä¾§ã€‚ å¶:å¡«ä¸€åŠ; å¥‡:ä¸åŒ…å«ä¸­ç‚¹
    while True:
        half_stack.append(slow.data)
        if quick.next is None:  # å¶
            mid_r = slow.next
            break
        if quick.next.next is None:  # å¥‡
            mid_r = slow.next.next
            break
        slow = slow.next
        quick = quick.next.next
    while mid_r is not None:
        if (mid_r.data != half_stack.pop()):
            return False
        mid_r = mid_r.next
    return True


def is_palindrome_linked_list3(head):
    if head is None:
        return False
    if head.next is None:
        return True
    # ä¸å€ŸåŠ©æ ˆ, è¿‡äº†ä¸­ç‚¹åå°†é“¾è¡¨åè½¬
    # ç„¶åä»é“¾è¡¨ä¸¤ä¾§å¾€å›ä¸€ä¸€æ¯”è¾ƒ, å¾€å›èµ°æ—¶å†æ¬¡åè½¬é“¾è¡¨
    slow = head
    quick = head.next
    mid_r = None
    while True:
        if quick.next is None:
            mid_r = slow.next
            break
        if quick.next.next is None:
            mid_r = slow.next.next
            break
        slow = slow.next
        quick = quick.next.next
    # ä» mid_r èŠ‚ç‚¹å¼€å§‹è¿›è¡Œåè½¬
    pr, p, pn = None, mid_r, mid_r.next
    while True:
        p.next = pr
        if pn is None:
            break
        pr = p
        p = pn
        pn = p.next
    # æ­¤æ—¶çš„ p æ˜¯å³é“¾è¡¨å¤´èŠ‚ç‚¹, mid_r æ˜¯å°¾èŠ‚ç‚¹
    # ç°åœ¨å†æ¬¡åè½¬å³é“¾è¡¨, åœ¨åè½¬çš„è¿‡ç¨‹ä¸­ä¸å·¦é“¾è¡¨ä¸€ä¸€æ¯”è¾ƒ
    left = head
    pr, p, pn = None, p, p.next
    is_palindrome = True
    while True:
        if left.data != p.data:
            is_palindrome = False
        p.next = pr
        if pn is None:
            break
        pr = p
        p = pn
        pn = p.next
        left = left.next
    return is_palindrome
```

### ç»ƒä¹  - å¯¹å•é“¾è¡¨çš„å€¼è¿›è¡Œåˆ’åˆ†

ã€é¢˜ç›®ã€‘: ç»™å®šä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head, èŠ‚ç‚¹çš„å€¼ç±»å‹æ˜¯æ•´å‹, å†ç»™å®šä¸€ä¸ªæ•´æ•° pivotã€‚
å®ç°ä¸€ä¸ªè°ƒæ•´é“¾è¡¨çš„å‡½æ•°, å°†é“¾è¡¨è°ƒæ•´ä¸ºå·¦éƒ¨åˆ†éƒ½æ˜¯å€¼å°äº pivot çš„èŠ‚ç‚¹, ä¸­é—´éƒ¨åˆ†éƒ½æ˜¯å€¼ç­‰äº pivot çš„èŠ‚ç‚¹, å³éƒ¨åˆ†éƒ½æ˜¯å€¼å¤§äº pivot çš„èŠ‚ç‚¹ã€‚
ã€è¿›é˜¶ã€‘: è¦æ±‚å®ç°ç¨³å®šæ€§, åŒæ—¶æ—¶é—´å¤æ‚åº¦ä¸º O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚

åšæ³• 1(ç¬”è¯•): æŠŠå•é“¾è¡¨è½¬æ¢ä¸ºæ•°ç»„, ç„¶ååšå¿«æ’çš„ partitionã€‚ åšå®Œåå†æŠŠæ•°ç»„è½¬æ¢ä¸ºå•é“¾è¡¨

åšæ³• 2(é¢è¯•): å¦‚ä½•ä¼˜åŒ–åšæ³•1?
é“¾è¡¨çš„ç§»åŠ¨ä»£ä»·ç›¸æ¯”æ•°ç»„å¾ˆä½, æ‰€ä»¥é“¾è¡¨çš„ partition å¯ä»¥ä»…ä»…ä½¿ç”¨æœ‰é™çš„å‡ ä¸ªå˜é‡å®ç°:
- åŸºæœ¬æ€è·¯: å®šä¹‰ä¸‰ä¸ªåŒºåŸŸçš„ç©ºé“¾è¡¨ã€‚ éå†é“¾è¡¨, å°†æ¯æ¬¡éå†åˆ°çš„èŠ‚ç‚¹æ”¾åˆ°æ­£ç¡®çš„åŒºåŸŸå†…ã€‚ éå†å®Œæˆåå°†ä¸‰ä¸ªåŒºåŸŸçš„é“¾è¡¨è¿æ¥èµ·æ¥å°±å¯ä»¥äº†ã€‚
1. å®šä¹‰ 6 ä¸ªå˜é‡, SH è¡¨ç¤º "< åŒº" çš„å¤´èŠ‚ç‚¹, ST è¡¨ç¤º "<" åŒºåŸŸçš„å°¾èŠ‚ç‚¹ã€‚ åŒç†è¿˜æœ‰ "= åŒº" çš„ä¸¤ä¸ªèŠ‚ç‚¹ EH å’Œ ET,   "> åŒº" çš„ä¸¤ä¸ªèŠ‚ç‚¹ BH å’Œ BTã€‚ ä»–ä»¬çš„åˆå§‹å€¼éƒ½æ˜¯ç©ºã€‚
2. éå†é“¾è¡¨
3. å½“èŠ‚ç‚¹ < åˆ’åˆ†å€¼æ—¶, å°†èŠ‚ç‚¹æ”¾åˆ° "< åŒº" çš„é“¾è¡¨ä¸Šã€‚å…·ä½“åšæ³•æ˜¯: ç¬¬ä¸€ä¸ªå°äºåˆ’åˆ†å€¼çš„èŠ‚ç‚¹, å°†å®ƒåŒæ—¶èµ‹å€¼ç»™ SH å’Œ ST, ç„¶å SH å°±ä¸ç”¨å˜äº†ã€‚ åç»­å†é‡åˆ°ç¬¦åˆæ¡ä»¶çš„èŠ‚ç‚¹æ—¶, å°†å®ƒä½œä¸º ST çš„ä¸‹ä¸€èŠ‚ç‚¹, åŒæ—¶ ST å‘ä¸‹ç§»åŠ¨, ä»¥æ­¤ç±»æ¨ã€‚
4. å½“èŠ‚ç‚¹ == åˆ’åˆ†å€¼æˆ–èŠ‚ç‚¹ > åˆ’åˆ†å€¼ æ—¶, éƒ½æ˜¯åŒæ ·çš„åšæ³•ã€‚
5. ç»“æŸæ—¶, å°†ä¸‰æ¡é“¾è¡¨è¿æ¥èµ·æ¥å°±å¯ä»¥äº†ã€‚ å…·ä½“åšæ³•æ˜¯: å°† ST ä¸ EH, ET ä¸ BH è¿æ¥èµ·æ¥ã€‚

#### è€å¸ˆä»£ç 

```java
// æ–¹æ³•1
public static Node listPartition1(Node head, int pivot) {
    if (head == null) {
        return head;
    }
    Node cur = head;
    // è·å–é“¾è¡¨é•¿åº¦
    int i = 0;
    while (cur != null) {
        i++;
        cur = cur.next;
    }
    // å°†é“¾è¡¨è½¬æ¢ä¸ºæ•°ç»„
    Node[] nodeArr = new Node[i];
    i = 0;
    cur = head;
    for (i = 0; i != nodeArr.length; i++) {
        nodeArr[i] = cur;
        cur = cur.next;
    }
    // åœ¨æ•°ç»„ä¸Šæ‰§è¡Œ partition
    arrPartition(nodeArr, pivot);
    // å°†æ•°ç»„é‡æ–°è¿æ¥æˆé“¾è¡¨
    for (i = 1; i != nodeArr.length; i++) {
        nodeArr[i - 1].next = nodeArr[i];
    }
    nodeArr[i - 1].next = null;
    return nodeArr[0];
}

public static void arrPartition(Node[] nodeArr, int pivot) {
    int small = -1;
    int big = nodeArr.length;
    int index = 0;
    while (index != big) {
        if (nodeArr[index].value < pivot) {
            swap(nodeArr, ++small; index++);
        } else if (nodeArr[index].value == pivot) {
            index ++;
        } else {
            swap(nodeArr, --big, index);
        }
    }
}

// æ–¹æ³•2
public static Node listPartition2(Node head, int pivot) {
    // åˆ›å»ºä¸‰æ¡é“¾è¡¨, åˆ†åˆ«å­˜æ”¾ä¸‰ç±»å€¼
    Node sH = null; // small head
    Node sT = null; // small tail
    Node eH = null;
    Node eT = null;
    Node bH = null;
    Node bT = null;
    Node next = null; // save next node

    // å°†èŠ‚ç‚¹åˆ†åˆ«æ”¾å…¥ä¸‰ç±»é“¾è¡¨ä¸Š
    while (head != null) {
        next = head.next;
        head.next = null;
        if (head.value < pivot) {
            if (sH == null) {
                sH = head;
                sT = head;
            } else {
                sT.next = head;
                sT = head;
            }
        } else if (head.value == pivot) {
            if (eH == null) {
                eH = head;
                eT = head;
            } else {
                eT.next = head;
                eT = head;
            }

        } else {
            if (bH == null) {
                bH = head;
                bT = head;
            } else {
                bT.next = head;
                bT = head;
            }
        }
        head = next;
    }


    if (sT != null) {
        // è‹¥æœ‰ s, s ç›´æ¥è¿ eH
        sT.next = eH;
        // æ­¤æ—¶è¦æ˜¯ eH æ²¡æœ‰, ä¸‹ä¸€ä¸ª if ä¼šæ•è·åˆ°, å¹¶æŠŠ s é‡æ–°è¿åˆ° b
        // è¦æ˜¯ e æœ‰,                       é‚£ä¹ˆ e å°±éœ€è¦è¿åˆ° b
        // ä¹Ÿå°±æ˜¯, ä¸ç®¡ e æœ‰æ²¡æœ‰, éƒ½éœ€è¦æœ‰äººè¿æ¥åˆ° b, è¦ä¹ˆæ˜¯ s è¿, è¦ä¹ˆæ˜¯ e è¿
        eT = eT == null ? sT : eT;
        // æ­¤æ—¶çš„ eT å¯èƒ½æ˜¯ s, ä¹Ÿå¯èƒ½æ˜¯ e
    }
    // å¦‚æœä¸Šä¸€ä¸ª if è¿›å»äº†, é‚£ä¹ˆè¿™é‡Œçš„ if ä¹Ÿä¸€å®šä¼šè¿›å»
    // å¦‚æœä¸Šä¸€ä¸ª if æ²¡è¿›å», é‚£ä¹ˆè¿™é‡Œçš„ if å¯èƒ½ä¼šè¿›å»
    if (eT != null) {
        eT.next = bH;
    }

    // è¿æ¥é¡ºåºæ˜¯ s-e-b, è¦æ˜¯æ²¡æœ‰ sH, é‚£å°±è¿”å› eH, è¦æ˜¯ eH ä¹Ÿæ²¡æœ‰, é‚£å°±è¿”å› bH
    // æ‰€ä»¥å‰é¢ä¸¤ä¸ª if åªéœ€è¦ç¡®ä¿ä¸‰ä¸ªåŒºåŸŸèƒ½è¿æ¥èµ·æ¥å°±å¯ä»¥ã€‚
    return sH != null ? sH : (eH != null ? eH : bH);
}

```

#### æˆ‘çš„ä»£ç 
```py
def linked_list_partition2(head, pivot):
    # ç¨³å®š
    if head is None or head.next is None:
        return head

    # åˆ›å»ºä¸‰æ¡é“¾è¡¨, åˆ†åˆ«å­˜æ”¾å¤§äºç­‰äºå°äº
    lH, lT = None, None
    eH, eT = None, None
    mH, mT = None, None
    p = head
    while p is not None:
        if p.data < pivot:
            if lH is None:
                lH = lT = p
            else:
                lT.next = p
                lT = p
        elif p.data == pivot:
            if eH is None:
                eH = eT = p
            else:
                eT.next = p
                eT = p
        else:
            if mH is None:
                mH = mT = p
            else:
                mT.next = p
                mT = p
        p = p.next

    # å°†ä¸‰æ¡é“¾è¡¨è¿åœ¨ä¸€èµ·ã€‚ åªéœ€è¦å¯¹ tail.next è¿›è¡Œæ“ä½œ
    if lT is not None:  # lT è¦ä¹ˆè¿ eH, è¦ä¹ˆè¿ mHã€‚ (è‡ªåŠ¨åŒ…å«äº† None çš„æƒ…å†µ)
        lT.next = eH if eH is not None else mH
    if eT is not None:  # eT åªä¼šè¿ mH (è‡ªåŠ¨åŒ…å«äº† None çš„æƒ…å†µ)
        eT.next = mH
    if mT is not None:  # mT åªä¼šè¿ None
        mT.next = None

    # åªéœ€è¿”å›ä¸‰ä¸ªå¤´ä¸­çš„ä¸€ä¸ª, ä¼˜å…ˆçº§æ˜¯ lH > eH > mH
    return lH if lH is not None else (eH if eH is not None else mH)

```


### ç»ƒä¹  - å¤åˆ¶å«æœ‰éšæœºæŒ‡é’ˆèŠ‚ç‚¹çš„é“¾è¡¨

ã€é¢˜ç›®ã€‘: ä¸€ç§ç‰¹æ®Šçš„å•é“¾è¡¨èŠ‚ç‚¹ç±»æè¿°å¦‚ä¸‹
```java
class Node {
    int value;
    Node next;
    Node rand;
    Node(int val){
        value = val;
    }
}
```
rand æŒ‡é’ˆæ˜¯å•é“¾è¡¨èŠ‚ç‚¹ç»“æ„ä¸­æ–°å¢çš„æŒ‡é’ˆ, rand å¯èƒ½æŒ‡å‘é“¾è¡¨ä¸­çš„ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹, ä¹Ÿå¯èƒ½æŒ‡å‘ nullã€‚
ç»™å®šä¸€ä¸ªç”± Node èŠ‚ç‚¹ç±»å‹ç»„æˆçš„æ— ç¯å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head, è¯·å®ç°ä¸€ä¸ªå‡½æ•°å®Œæˆè¿™ä¸ªé“¾è¡¨çš„å¤åˆ¶, å¹¶è¿”å›å¤åˆ¶çš„æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹

ã€è¦æ±‚ã€‘: æ—¶é—´å¤æ‚åº¦ O(N), é¢å¤–ç©ºé—´å¤æ‚åº¦ O(1)

ã€è§£é‡Šé¢˜ç›®ã€‘: è¿™ä¸ªé“¾è¡¨å’Œæ™®é€šé“¾è¡¨çš„åŒºåˆ«åœ¨äº, ä»–å¤šäº† rand è¿™ä¸ªå±æ€§ã€‚ å½“æˆ‘ä»¬å¤åˆ¶é“¾è¡¨æ—¶, è¦æ±‚æŠŠæ¯ä¸ªèŠ‚ç‚¹ä¸Šçš„ rand çš„æŒ‡å‘ä¹ŸæˆåŠŸå¤åˆ¶ã€‚

åšæ³• 1(ç¬”è®°): åˆ›å»ºä¸€ä¸ª Map, å®ƒçš„ key æ˜¯æ—§é“¾è¡¨èŠ‚ç‚¹, value æ˜¯æ–°èŠ‚ç‚¹(å³æ—§èŠ‚ç‚¹çš„å…‹éš†ä½“)ã€‚ å…ˆéå†ä¸€éé“¾è¡¨, å®Œæˆæ‰€æœ‰èŠ‚ç‚¹å€¼çš„æ‹·è´, æ­¤æ—¶çš„æ‹·è´å¹¶ä¸åŒ…å« next å’Œ randã€‚ å†éå†æ—§é“¾è¡¨, é€šè¿‡æ—§é“¾è¡¨è·å– next èŠ‚ç‚¹å’Œ rand èŠ‚ç‚¹, å°†æ—§é“¾è¡¨çš„èŠ‚ç‚¹ä½œä¸º key, å¯ä»¥è·å–å°±èŠ‚ç‚¹æ‰€å¯¹åº”çš„æ–°èŠ‚ç‚¹çš„åœ°å€, ç„¶åå°†æ–°èŠ‚ç‚¹çš„åœ°å€èµ‹å€¼ç»™ æ–°èŠ‚ç‚¹çš„ next å’Œ randã€‚

åšæ³• 2(é¢è¯•): ä¸å€ŸåŠ©å“ˆå¸Œè¡¨å¦‚ä½•å®ç°?
å…ˆåˆ†æé¢˜ç›®, å¯¹äºé“¾è¡¨çš„å…‹éš†, é‡ç‚¹åœ¨äºæˆ‘ä»¬å…‹éš†åæ–°èŠ‚ç‚¹çš„ä½ç½®, å…³é”®ç‚¹åœ¨äº, ä¸ä½¿ç”¨ Map, æˆ‘ä»¬è¦å¦‚ä½•å­˜å‚¨æ–°èŠ‚ç‚¹çš„ä½ç½®?
ç­”æ¡ˆå°±æ˜¯å°†æ–°å…‹éš†çš„èŠ‚ç‚¹æ”¾åˆ°æ—§é“¾è¡¨ä¸Š, è¿™æ ·å°±çœç•¥äº†å­˜å‚¨æ–°èŠ‚ç‚¹å¼•ç”¨çš„ç©ºé—´äº†!
å…·ä½“å®ç°å°±æ˜¯, ç¬¬ä¸€æ¬¡éå†æ—§èŠ‚ç‚¹æ—¶, åˆ›å»ºå‡ºå½“å‰èŠ‚ç‚¹çš„å…‹éš†èŠ‚ç‚¹, åŒæ—¶å°†å…‹éš†èŠ‚ç‚¹åŠ å…¥åˆ°å½“å‰æ—§èŠ‚ç‚¹å’Œä¸‹ä¸€ä¸ªæ—§èŠ‚ç‚¹ä¹‹é—´ã€‚
ç¬¬äºŒæ¬¡éå†é“¾è¡¨æ—¶, åˆ©ç”¨åˆ©ç”¨æ—§èŠ‚ç‚¹çš„ next.next å’Œ rand.next, å°±å¯ä»¥å¾—åˆ°æ–°èŠ‚ç‚¹çš„ä½ç½®äº†ã€‚
æ‰€æœ‰æ¯ä¸ªæ–°èŠ‚ç‚¹è·å–å®Œ next å’Œ rand æ‰€å¯¹åº”çš„æ–°èŠ‚ç‚¹å, å°±å¯ä»¥å°†æ–°èŠ‚ç‚¹åœ¨æ—§é“¾è¡¨ä¸Šåˆ é™¤ã€‚

```
â•­  â”€  â•®                 â•­  â”€  â•®                 â•­  â”€  â•®                 â•­  â”€  â•®                 â•­  â”€  â•®
â”‚old1 â”‚      -->        â”‚old2 â”‚      -->        â”‚old3 â”‚      -->        â”‚old4 â”‚      -->        â”‚old5 â”‚      -->        ....
â•°  â”€  â•¯                 â•°  â”€  â•¯                 â•°  â”€  â•¯                 â•°  â”€  â•¯                 â•°  â”€  â•¯
å°†æ–°å…‹éš†çš„èŠ‚ç‚¹æ”¾åˆ°æ—§é“¾è¡¨ä¸Š
â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®     â•­  â”€  â•®
â”‚old1 â”‚ --> â”‚ new1â”‚ --> â”‚old2 â”‚ --> â”‚ new2â”‚ --> â”‚old3 â”‚ --> â”‚ new3â”‚ --> â”‚old4 â”‚ --> â”‚ new4â”‚ --> â”‚old5 â”‚ --> â”‚ new5â”‚ ---> ....
â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯     â•°  â”€  â•¯
```

#### è€å¸ˆä»£ç :

```java
// åšæ³•1
public static Node copyListWithRand1(Node head) {
    HashMap<Node, Node> map = new HashMap<Node, Node>();

    // ç¬¬ä¸€æ¬¡éå†: æ‹·è´æ‰€æœ‰æ—§èŠ‚ç‚¹
    Node cur = head;
    while (cur != null) {
        map.put(cur, new Node(cur.value));
        cur = cur.next;
    }

    // ç¬¬äºŒæ¬¡éå†: ä¸ºæ–°èŠ‚ç‚¹çš„ next å’Œ rand èµ‹å€¼æ–°èŠ‚ç‚¹çš„å¼•ç”¨
    cur = head;
    while (cur != null) {
        // å°†æ—§èŠ‚ç‚¹çš„ next èŠ‚ç‚¹ æ‰€å¯¹åº”çš„æ–°èŠ‚ç‚¹å¤åˆ¶ç»™æ–°èŠ‚ç‚¹çš„ next
        map.get(cur).next = map.get(cur.next);
        mpa.get(cur).rand = map.get(cur.rand);
        cur = cur.next;
    }
    return map.get(head);
}

// åšæ³•2
public static Node copyListWithRand2(Node head) {
    if (head == null) {
        return null;
    }

    // 1. å°†æ–°åˆ›å»ºçš„å…‹éš†èŠ‚ç‚¹æ”¾åˆ°æ—§é“¾è¡¨ä¸Šã€‚
    Node cur = head;
    Node next = null;
    while (cur != null) {
        next = cur.next;
        cur.next = new Node(cur.value);
        cur.next.next = next;
        cur = next;
    }

    // 2. ä¸ºæ–°åˆ›å»ºçš„å…‹éš†èŠ‚ç‚¹çš„ rand èµ‹å€¼
    cur = head;
    Node curCopy = null;
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        curCopy.rand = cur.rand != null? cur.rand.next : null;
        cur = next;
    }

    // 3. å°†å…‹éš†é“¾è¡¨æŠ½ç¦»å‡ºæ¥
    Node res = head.next;
    cur = head;
    while (cur != null) {
        next = cur.next.next;
        curCopy = cur.next;
        cur.next = next;
        curCopy.next = next != null ? next.next : null;
        cur = next;
    }
    return res;

}
```